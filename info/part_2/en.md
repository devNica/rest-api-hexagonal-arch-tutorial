Welcome to the second part of this hexagonal architecture tutorial,
implemented to a RESTAPI with NodeJS and Typescript.

In this video we are going to advance with our project and we are going to create
our first module that will contain the logic for authentication
of the users.

I clarify that in this part we are not going to work with databases yet,
If not, the purpose is to leave the base structure with which it is going to be segmented
all the part of account registration and user login,
to then focus on the different options available
that allow us to connect to a relational database.

If you are a good observer you will realize that we will apply
the same separation of concepts as we did with the Core of the application.
so our pattern must be implemented in every piece of code
of our project and this will allow us to decouple from infrastructure implementations.

We will basically have the following directories:

adapters:  Where we will have the implementations of our controllers and repositories according to the case

ports:      Here we define the interfaces that allow the core of the module to interact with the
            outside world, through events or external requests (requets) or internal
            (events generated by the core of the app)

models:     Where we will find the definitions of data types that will be used later
            through interfaces or ports.

usecases:   Here we are going to define the different use cases that we are going to address in this authentication module,
            that is, user registration, login, etc.
factories:  This is where our controllers take shape, adding to each one only those
            parts required according to your definition.


Routes:     This directory will contain all the routes defined for this module.


Well, with this we already have the bases of our module implemented
with the Hexagonal Architecture, we have made a request to the route
user registration, which has been processed correctly
returning the user ID, which at the moment we are
establishing in the case of use, but the ideal will be when
we have connected our core with the database, to
Let the repository take care of returning this information to us.

In the next video, we will see how to uncouple from the Express Framework,
so that our routes are not coupled to implementations, but
that we can change at any time that is necessary from framework
or libraries to handle requests to the server.

See you in a next video!